from datetime import datetime
from database.serverHelper import append_to_main_dictionary, create_print_job, check_print_job_exists, get_dictionary, update_dictionary
import io
from scripts.classes.dataclass import DataClass
import streamlit as st
import re

def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False

def is_integer(s):
    try:
        int(s)
        return True
    except ValueError:
        return False

def is_percentage(s):
    if s.endswith('%'):
        try:
            float(s[:-1])
            return True
        except ValueError:
            return False
    return False

def is_json(s):
    s = s.strip()
    return (s.startswith('{') and s.endswith('}')) or (s.startswith('[') and s.endswith(']'))

def is_time_str(v):
    return isinstance(v, str) and re.search(r"\d+[hms]", v)

def parse_time(v):
    hours = minutes = seconds = 0
    match_h = re.search(r"(\d+)h", v)
    match_m = re.search(r"(\d+)m", v)
    match_s = re.search(r"(\d+)s", v)
    if match_h:
        hours = int(match_h.group(1))
    if match_m:
        minutes = int(match_m.group(1))
    if match_s:
        seconds = int(match_s.group(1))
    return hours * 3600 + minutes * 60 + seconds

def convert_value(value):
    if is_integer(value):
        return int(value)
    elif is_number(value):
        return float(value)
    elif is_percentage(value):
        return float(value[:-1]) / 100.0
    elif is_json(value):
        import json
        try:
            return json.loads(value)
        except json.JSONDecodeError:
            return value
    elif is_time_str(value):
        return parse_time(value)
    return value

def is_prusaslicer(line):
    if line.startswith("; generated by PrusaSlicer"):
        return True
    return False

def get_date_from_prusaslicer(line):
    match = re.search(r"on (\d{4}-\d{2}-\d{2}) at (\d{2}:\d{2}:\d{2}) UTC", line)
    if match:
        date_str = f"{match.group(1)} {match.group(2)}"
        dt = datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
        return dt
    return None

def recognize_slicer(line):
    if is_prusaslicer(line):
        return "PrusaSlicer"
    return "Unknown"

def handle_gcode(file):
    info = {}
    is_thumbnail = False
    first_line = True

    with io.TextIOWrapper(io.BytesIO(file.bytes), encoding="ascii", errors="ignore") as f:
        for line in f:
            if first_line:
                first_line = False
                slicer = recognize_slicer(line)
                info["Slicer"] = slicer


                if slicer == "PrusaSlicer":
                    dt = get_date_from_prusaslicer(line)
                    if dt is not None:
                        info["Slicing Date (UTC)"] = dt.isoformat()


            if line.startswith("; thumbnail_QOI begin"):
                is_thumbnail = True
            if line.startswith("; thumbnail_QOI end"):
                is_thumbnail = False
            if is_thumbnail:
                continue


            line = line.strip()
            if line.startswith(";") and "=" in line:
                line = line[1:].strip()
                key, value = line.split("=", 1)
                key = key.strip()
                value = value.strip()
                if (is_time_str(value)): 
                    key = key + " (seconds)"
                info[key] = convert_value(value)
                # info[key] = value


    # st.subheader("G-code Metadata")
    # st.json(info)
    # st.write(f"Total metadata entries: {len(info)}")

    return info

def transform_info_keys(info, printer_name, slicer):
    dictionary, d_id = get_dictionary(printer_name, slicer)
    new_keys_to_keys = {}

    new_info = {}

    if dictionary is not None:
        for k in info.keys():
            if k in dictionary:
                new_info[dictionary[k]] = info[k]
            else:
                new_info[k] = info[k]
                new_keys_to_keys[k] = k


        update_dictionary(d_id, new_keys_to_keys)
        append_to_main_dictionary(new_keys_to_keys)

    print(new_info)
    return new_info

def print_job_pipeline(file_data: DataClass, printer_id=None, object_id=None): 
    # file_datas is a list of file-like objects
    # At this moment, we will consider that the only file is a G-code file
    extracted_data = {}

    existing = None
    if file_data is not None:
        existing = check_print_job_exists(printer_id, object_id, [file_data])
    if existing is not None:
        return existing["_id"], existing.get("artifacts", {}).get("file_ids", [])

    if file_data is not None:
        info = handle_gcode(file_data)

        printer_name = printer_id or ""
        slicer = info.get("Slicer")

        info = transform_info_keys(info, printer_name, slicer)

        extracted_data.update(info)

        object_id, file_ids = create_print_job([file_data], printer_id, object_id, extracted_data)
        return object_id, file_ids
    return None, []